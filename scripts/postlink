const glob = require('glob');
const fs = require('fs');
const inquirer = require('inquirer');
const xcode = require('xcode');
const chalk = require('chalk');

const PLATFORMS = ['android', 'ios'];
const OBJC_HEADER = '\
#if __has_include(<React/RNSentry.h>)\n\
#import <React/RNSentry.h> // This is used for versions of react >= 0.40\n\
#else\n\
#import "RNSentry.h" // This is used for versions of react < 0.40\n\
#endif';

let cachedDsn = null;
let cachedProps = {};
let patchedAny = false;
let didShowInfoHint = false;
let configurePlatform = {};

function getPlatformName(platform) {
  return {
    'android': 'Android',
    'ios': 'iOS',
  }[platform] || platform;
}

function considerShowingInfoHint() {
  if (didShowInfoHint) {
    return;
  }
  console.log('');
  console.log(chalk.green(
    'You are about to configure Sentry for React Native'));
  console.log(chalk.dim(
    'We will ask you a bunch of questions to configure Sentry for you.'));
  console.log(chalk.dim(
    'If you chose not to configure an integration you can run link again'));
  console.log(chalk.dim(
    'later to configure that platform.'));
  console.log('');
  console.log('You will need an API key and the DSN for the application');
  console.log('You can find these at https://sentry.io/api/');
  console.log('');
  didShowInfoHint = true;
}

function shouldConfigurePlatform(platform) {
  if (configurePlatform[platform] !== undefined) {
    return Promise.resolve(configurePlatform[platform]);
  }
  // if a sentry.properties file exists for the platform we want to configure
  // without asking the user.  This means that re-linking later will not
  // bring up a useless dialog.
  if (fs.existsSync(platform + '/sentry.properties')) {
    configurePlatform[platform] = true;
    return Promise.resolve(true);
  }
  considerShowingInfoHint();
  return inquirer.prompt([{
    type: 'list',
    name: 'configure',
    message: `Do you want to configure Sentry for ${getPlatformName(platform)}?`,
    choices: [
      {
        name: 'Yes',
        value: true
      },
      {
        name: 'No (or later)',
        value: false
      }
    ]
  }]).then(function(answers) {
    configurePlatform[platform] = answers.configure;
    return Promise.resolve(answers.configure);
  });
}

function getDsn(platform) {
  considerShowingInfoHint();
  return inquirer.prompt([{
    type: 'input',
    default: cachedDsn || process.env.SENTRY_DSN || 'YOUR_DSN_HERE',
    message: 'The DSN for ' + getPlatformName(platform),
    name: 'dsn',
    validate: function(value) {
      let m = value.match(/^(?:(\w+):)?\/\/(?:(\w+)(:\w+)?@)?([\w\.-]+)(?::(\d+))?(\/.*)$/);
      if (!m) {
        return 'invalid dsn format';
      }
      if (m[1] !== 'http' && m[1] !== 'https') {
        return 'unsupported protocol for dsn: ' + m[1];
      }
      if (!m[3]) {
        return 'missing secret in dsn';
      }
      return true;
    }
  }]).then(function(answers) {
    cachedDsn = answers.dsn;
    return Promise.resolve(answers.dsn);
  });
}

function getDefaultUrl() {
  if (cachedDsn) {
    let match = cachedDsn.match(/^(https?).*?@(.*?)\//);
    if (match) {
      return match[1] + '://' + match[2] + '/';
    }
  }
  return 'https://sentry.io/';
}

function getProperties(platform) {
  return inquirer.prompt([{
    type: 'input',
    default: cachedProps['defaults/url'] || process.env.SENTRY_URL || getDefaultUrl(),
    message: 'The Sentry Server URL for ' + getPlatformName(platform),
    name: 'defaults/url',
  }, {
    type: 'input',
    default: cachedProps['defaults/org'] || process.env.SENTRY_ORG || 'your-org-slug',
    message: 'The Organization for ' + getPlatformName(platform),
    name: 'defaults/org',
  }, {
    type: 'input',
    default: cachedProps['defaults/project'] || process.env.SENTRY_PROJECT || 'your-project-slug',
    message: 'The Project for ' + getPlatformName(platform),
    name: 'defaults/project',
  }, {
    type: 'password',
    default: cachedProps['auth/token'] || process.env.SENTRY_AUTH_TOKEN || 'YOUR_AUTH_TOKEN',
    message: 'The Auth-Token for ' + getPlatformName(platform),
    name: 'auth/token',
  }]).then(function(answers) {
    cachedProps = answers;
    return Promise.resolve(answers);
  });
}

function dumpProperties(props) {
  let rv = [];
  for (let key in props) {
    let value = props[key];
    key = key.replace(/\//g, '.');
    if (value === undefined || value === null) {
      rv.push('#' + key + '=');
    } else {
      rv.push(key + '=' + value);
    }
  }
  return rv.join('\n') + '\n';
}

function patchAppDelegate(contents) {
  // add the header if it's not there yet.
  if (!contents.match(/#import "RNSentry.h"/)) {
    contents = contents.replace(
      /(#import <React\/RCTRootView.h>)/,
      '$1\n' + OBJC_HEADER
    );
  }

  // add root view init.
  let rootViewMatch = contents.match(/RCTRootView\s*\*\s*([^\s=]+)\s*=\s*\[/);
  if (rootViewMatch) {
    let rootViewInit = '[RNSentry installWithRootView:' + rootViewMatch[1] + '];';
    if (contents.indexOf(rootViewInit) < 0) {
      contents = contents.replace(
        /^(\s*)RCTRootView\s*\*\s*[^\s=]+\s*=\s*\[([^]*?\s*\]\s*;\s*$)/m,
        function(match, indent) {
          return match.trimRight() + '\n' + indent + rootViewInit + '\n';
        }
      );
    }
  }

  return Promise.resolve(contents);
}

function patchIndexJs(contents, filename) {
  // since the init call could live in other places too, we really only
  // want to do this if we managed to patch any of the other files as well.
  if (contents.match(/Sentry.config\(/) || !patchedAny) {
    return Promise.resolve(null);
  }

  let platform = filename.match(/index\.([^.]+?)\.js/)[1];
  return shouldConfigurePlatform(platform).then((shouldConfigure) => {
    if (!shouldConfigure) {
      return null;
    }

    return getDsn(platform).then(function(dsn) {
      return Promise.resolve(contents.replace(/^([^]*)(import\s+[^;]*?;$)/m, function(match) {
        return match + '\n\nimport { Sentry } from \'react-native-sentry\';\n\n' +
          'Sentry.config(' + JSON.stringify(dsn) + ').install();\n';
      }));
    });
  });
}

function patchBuildGradle(contents) {
  let applyFrom = 'apply from: "../../node_modules/react-native-sentry/sentry.gradle"';
  if (contents.indexOf(applyFrom) >= 0) {
    return Promise.resolve(null);
  }

  return shouldConfigurePlatform('android').then((shouldConfigure) => {
    if (!shouldConfigure) {
      return null;
    }

    return Promise.resolve(contents.replace(
      /^apply from: "..\/..\/node_modules\/react-native\/react.gradle"/m,
      function(match) {
        return match + '\n' + applyFrom;
      }
    ));
  });
}

function patchAlwaysIncludeSwift(proj) {
  let nativeTargets = proj.hash.project.objects.PBXNativeTarget;
  let buildConfigs = proj.pbxXCBuildConfigurationSection();

  for (let key in nativeTargets) {
    let data = nativeTargets[key];
    if (typeof data === 'string') {
      continue;
    }

    if (!data.productReference_comment.match(/\.app$/)) {
      continue;
    }

    let cfgList = proj.pbxXCConfigurationList()[data.buildConfigurationList];
    if (!cfgList) {
      continue;
    }

    for (let cfgRef of cfgList.buildConfigurations) {
      let cfg = buildConfigs[cfgRef.value];
      cfg.buildSettings.ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = 'YES';
    }
  }
}

function patchExistingXcodeBuildScripts(buildScripts) {
  for (let script of buildScripts) {
    if (!script.shellScript.match(/packager\/react-native-xcode\.sh\b/) ||
        script.shellScript.match(/sentry-cli\s+react-native-xcode/)) {
      continue;
    }
    let code = JSON.parse(script.shellScript);
    code = (
      'export SENTRY_PROPERTIES=sentry.properties\n' +
      code.replace(/^.*?\/packager\/react-native-xcode\.sh\s*/m, function(match) {
        return '../node_modules/sentry-cli-binary/bin/sentry-cli react-native-xcode ' + match;
      })
    );
    script.shellScript = JSON.stringify(code);
  }
}

function addNewXcodeBuildPhaseForSymbols(buildScripts, proj) {
  for (let script of buildScripts) {
    if (script.shellScript.match(/sentry-cli\s+upload-dsym/)) {
      return;
    }
  }

  proj.addBuildPhase(
    [],
    'PBXShellScriptBuildPhase',
    'Upload Debug Symbols to Sentry',
    null,
    {
      shellPath: '/bin/sh',
      shellScript: (
        '"export SENTRY_PROPERTIES=sentry.properties\\n' +
        '../node_modules/sentry-cli-binary/bin/sentry-cli upload-dsym"'
      )
    }
  );
}

function addNewXcodeBuildPhaseForBundleFw(buildScripts, proj) {
  for (let script of buildScripts) {
    if (script.shellScript.match(/react-native-sentry\/bin\/bundle-frameworks/)) {
      return;
    }
  }

  proj.addBuildPhase(
    [],
    'PBXShellScriptBuildPhase',
    'Bundle react-native-sentry Frameworks',
    null,
    {
      shellPath: '/bin/sh',
      shellScript: (
        '"../node_modules/react-native-sentry/bin/bundle-frameworks"'
      )
    }
  );
}

function patchXcodeProj(contents, filename) {
  let proj = xcode.project(filename);
  return new Promise(function(resolve, reject) {
    proj.parse(function(err) {
      if (err) {
        reject(err);
        return;
      }

      let buildScripts = Object.values(
          proj.hash.project.objects.PBXShellScriptBuildPhase || {})
        .filter((val) => val.isa);

      patchAlwaysIncludeSwift(proj);
      patchExistingXcodeBuildScripts(buildScripts);
      addNewXcodeBuildPhaseForSymbols(buildScripts, proj);
      addNewXcodeBuildPhaseForBundleFw(buildScripts, proj);

      // we always modify the xcode file in memory but we only want to save it
      // in case the user wants configuration for ios.  This is why we check
      // here first if changes are made before we might prompt the platform
      // continue prompt.
      let newContents = proj.writeSync();
      if (newContents === contents) {
        resolve(null);
      } else {
        return shouldConfigurePlatform('ios').then((shouldConfigure) => {
          resolve(shouldConfigure ? newContents : null);
        });
      }
    });
  });
}

function patchMatchingFile(pattern, func) {
  let matches = glob.sync(pattern, {
    ignore: 'node_modules/**'
  });
  let rv = Promise.resolve();
  matches.forEach(function(match) {
    let contents = fs.readFileSync(match, {
      encoding: 'utf-8'
    });
    rv = rv.then(() => func(contents, match)).then(function(newContents) {
      if (newContents !== null && contents !== undefined && contents != newContents) {
        patchedAny = true;
        fs.writeFileSync(match, newContents);
      }
    });
  });
  return rv;
}

function addSentryProperties() {
  let rv = Promise.resolve();

  for (let platform of PLATFORMS) {
    let fn = platform + '/sentry.properties';
    if (fs.existsSync(fn)) {
      continue;
    }

    rv = rv.then(() => shouldConfigurePlatform(platform).then((shouldConfigure) => {
      if (!shouldConfigure) {
        return null;
      }
      return getProperties(platform).then((props) => {
        fs.writeFileSync(fn, dumpProperties(props));
      });
    }));
  }

  return rv;
}

Promise.resolve()
  .then(() => patchMatchingFile('**/app/build.gradle', patchBuildGradle))
  .then(() => patchMatchingFile('**/*.xcodeproj/project.pbxproj', patchXcodeProj))
  .then(() => patchMatchingFile('**/AppDelegate.m', patchAppDelegate))
  .then(() => patchMatchingFile('index.android.js', patchIndexJs))
  .then(() => patchMatchingFile('index.ios.js', patchIndexJs))
  .then(() => addSentryProperties())
  .catch(function(e) {
    console.log('Could not link react-native-sentry: ' + e);
    return Promise.resolve();
  });
